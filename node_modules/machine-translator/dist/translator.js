'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * translator.js
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license MIT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Translator module. Uses statistical machine translation to
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * translate between two different languages. Loosely based on
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the IMB model 1 algorithm.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _text2token = require('text2token');

var _text2token2 = _interopRequireDefault(_text2token);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Translator = function () {
  function Translator() {
    _classCallCheck(this, Translator);

    this.foreignWords = [];
    this.foreignLines = [];
    this.nativeWords = [];
    this.nativeLines = [];
    this.devWords = [];
    this.sentencePairs = [];

    this.probs = {};
    this.transmissions = {}; // this is t(elf)
    this.countef = {};
    this.totalf = {};
    this.totals = {};
  }

  _createClass(Translator, [{
    key: 'train',
    value: function train(nativeText, foreignText) {

      if (nativeText === undefined || foreignText === undefined) {
        throw new Error('Native and Foreign Texts are both required!');
      }

      var convertedData = _text2token2.default.text2token(nativeText);
      this.nativeLines = convertedData.lines;
      this.nativeWords = convertedData.tokens;

      var convertedForeignData = _text2token2.default.text2token(foreignText);
      this.foreignLines = convertedForeignData.lines;
      this.foreignWords = convertedForeignData.tokens;

      this.sentencePairs = [];

      for (var index = 0; index < this.nativeLines.length; index++) {
        this.sentencePairs.push([this.nativeLines[index], this.foreignLines[index]]);
      }

      this._initTransmissions();
      this._iterateEM(10);
    }
  }, {
    key: '_initTransmissions',
    value: function _initTransmissions() {
      var _this = this;

      var probs = {},
          transmissions = {};

      var _loop = function _loop(wordIndex) {
        var word = _this.nativeWords[wordIndex];
        var word_poss = [];

        // if word is in sentence then...
        for (var lineIndex = 0; lineIndex < _this.nativeLines.length; lineIndex++) {
          var sentence = _this.nativeLines[lineIndex];
          if (sentence.indexOf(word) > -1) {
            var matching = _this.foreignLines[_this.nativeLines.indexOf(sentence)];
            var matches = matching.split(' ');
            matches.forEach(function (match) {
              return word_poss.push(match);
            });
          }
        }

        /** Remove duplicates. */
        /** Add probable matches. */
        probs[word] = _underscore2.default.unique(word_poss);
      };

      for (var wordIndex = 0; wordIndex < this.nativeWords.length; wordIndex++) {
        _loop(wordIndex);
      }

      this.probs = probs;

      for (var wordIndex = 0; wordIndex < this.nativeWords.length; wordIndex++) {
        var _word = this.nativeWords[wordIndex];
        var word_probs = this.probs[_word];

        var uniform_prob = 1.0 / word_probs.length;

        var prob_set = {};

        for (var probIndex = 0; probIndex < word_probs.length; probIndex++) {
          var w = word_probs[probIndex];
          prob_set[w] = uniform_prob;
        }

        transmissions[_word] = prob_set;
      }

      this.transmissions = transmissions;
    }
  }, {
    key: '_iterateEM',
    value: function _iterateEM(count) {
      var _this2 = this;

      var _loop2 = function _loop2(index) {
        var totalf = {},
            countef = {};

        for (var wordIndex = 0; wordIndex < _this2.nativeWords.length; wordIndex++) {
          var _word2 = _this2.nativeWords[wordIndex];

          if (!_this2.probs.word) {
            continue;
          }
          /* istanbul ignore next */
          var word_probs = _this2.probs[_word2];
          /* istanbul ignore next */
          var prob_set = {};
          /* istanbul ignore next */
          for (var probIndex = 0; probIndex < word_probs.length; probIndex++) {
            var w = word_probs[probIndex];
            prob_set[w] = 0;
          }
          /* istanbul ignore next */
          countef[_word2] = count;
          /* istanbul ignore next */
          totalf[_word2] = 0;
        }

        _this2.countef = countef;
        _this2.totalf = totalf;

        var self = _this2;

        /** Iterate over each sentence pair. */
        _this2.sentencePairs.forEach(function (sentence) {

          var nativeTokens = sentence[0].split('');
          var foreignTokens = sentence[1].split('');

          for (var foreign = 0; foreign < foreignTokens.length; foreign++) {
            _this2.totals[foreign] = 0;
            for (var native = 0; native < nativeTokens.length; native++) {
              if (!_this2.transmissions.n) {
                continue;
              }
              /* istanbul ignore next */
              if (!_this2.transmissions.n.f) {
                continue;
              }
              /* istanbul ignore next */
              _this2.countef[native][foreign] += _this2.transmissions[native][foreign] / _this2.totals[foreign];
              /* istanbul ignore next */
              _this2.totalf[native] += _this2.transmissions[native][foreign] / _this2.totals[foreign];
            }
          }

          for (var _native = 0; _native < nativeTokens.length; _native++) {
            if (!_this2.probs.n) {
              continue;
            }
            /* istanbul ignore next */
            var n_prob = self.probs[_native];
            /* istanbul ignore next */
            for (var _foreign = 0; _foreign < n_prob.length; _native++) {
              _this2.transmissions[_native][_foreign] = _this2.countef[_native][_foreign] / _this2.totalf[_native];
            }
          }
        });
      };

      for (var index = 0; index < count; index++) {
        _loop2(index);
      }
    }
  }, {
    key: 'translate',
    value: function translate(nativeWord) {
      if (!this.transmissions[nativeWord] || nativeWord === undefined) {
        throw new Error('No match found!');
      }
      return this.transmissions[nativeWord];
    }
  }]);

  return Translator;
}();

exports.default = Translator;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90cmFuc2xhdG9yLmpzIl0sIm5hbWVzIjpbIlRyYW5zbGF0b3IiLCJmb3JlaWduV29yZHMiLCJmb3JlaWduTGluZXMiLCJuYXRpdmVXb3JkcyIsIm5hdGl2ZUxpbmVzIiwiZGV2V29yZHMiLCJzZW50ZW5jZVBhaXJzIiwicHJvYnMiLCJ0cmFuc21pc3Npb25zIiwiY291bnRlZiIsInRvdGFsZiIsInRvdGFscyIsIm5hdGl2ZVRleHQiLCJmb3JlaWduVGV4dCIsInVuZGVmaW5lZCIsIkVycm9yIiwiY29udmVydGVkRGF0YSIsInJlYWRlciIsInRleHQydG9rZW4iLCJsaW5lcyIsInRva2VucyIsImNvbnZlcnRlZEZvcmVpZ25EYXRhIiwiaW5kZXgiLCJsZW5ndGgiLCJwdXNoIiwiX2luaXRUcmFuc21pc3Npb25zIiwiX2l0ZXJhdGVFTSIsIndvcmRJbmRleCIsIndvcmQiLCJ3b3JkX3Bvc3MiLCJsaW5lSW5kZXgiLCJzZW50ZW5jZSIsImluZGV4T2YiLCJtYXRjaGluZyIsIm1hdGNoZXMiLCJzcGxpdCIsImZvckVhY2giLCJtYXRjaCIsIl8iLCJ1bmlxdWUiLCJ3b3JkX3Byb2JzIiwidW5pZm9ybV9wcm9iIiwicHJvYl9zZXQiLCJwcm9iSW5kZXgiLCJ3IiwiY291bnQiLCJzZWxmIiwibmF0aXZlVG9rZW5zIiwiZm9yZWlnblRva2VucyIsImZvcmVpZ24iLCJuYXRpdmUiLCJuIiwiZiIsIm5fcHJvYiIsIm5hdGl2ZVdvcmQiXSwibWFwcGluZ3MiOiI7Ozs7OztxakJBQUE7Ozs7Ozs7Ozs7QUFVQTs7OztBQUNBOzs7Ozs7OztJQUVxQkEsVTtBQUVuQix3QkFBYztBQUFBOztBQUNaLFNBQUtDLFlBQUwsR0FBc0IsRUFBdEI7QUFDQSxTQUFLQyxZQUFMLEdBQXNCLEVBQXRCO0FBQ0EsU0FBS0MsV0FBTCxHQUFzQixFQUF0QjtBQUNBLFNBQUtDLFdBQUwsR0FBc0IsRUFBdEI7QUFDQSxTQUFLQyxRQUFMLEdBQXNCLEVBQXRCO0FBQ0EsU0FBS0MsYUFB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QUFDRDtBQUNEO0FBQ0EsZ0JBQU1FLFNBQVNQLEtBQUt2QyxLQUFMLENBQVcyQyxPQUFYLENBQWY7QUFDQTtBQUNBLGlCQUFLLElBQUlELFdBQVUsQ0FBbkIsRUFBc0JBLFdBQVVJLE9BQU85QixNQUF2QyxFQUErQzJCLFNBQS9DLEVBQXlEO0FBQ3ZELHFCQUFLMUMsYUFBTCxDQUFtQjBDLE9BQW5CLEVBQTJCRCxRQUEzQixJQUFzQyxPQUFLeEMsT0FBTCxDQUFheUMsT0FBYixFQUFxQkQsUUFBckIsSUFBZ0MsT0FBS3ZDLE1BQUwsQ0FBWXdDLE9BQVosQ0FBdEU7QUFDRDtBQUNGO0FBQ0YsU0FuQ0Q7QUFqQ2M7O0FBRWhCLFdBQUssSUFBSTVCLFFBQVEsQ0FBakIsRUFBb0JBLFFBQVF1QixLQUE1QixFQUFtQ3ZCLE9BQW5DLEVBQTRDO0FBQUEsZUFBbkNBLEtBQW1DO0FBbUUzQztBQUNGOzs7OEJBRVNnQyxVLEVBQVk7QUFDcEIsVUFBSSxDQUFDLEtBQUs5QyxhQUFMLENBQW1COEMsVUFBbkIsQ0FBRCxJQUFtQ0EsZUFBZXhDLFNBQXRELEVBQWlFO0FBQy9ELGNBQU0sSUFBSUMsS0FBSixDQUFVLGlCQUFWLENBQU47QUFDRDtBQUNELGFBQU8sS0FBS1AsYUFBTCxDQUFtQjhDLFVBQW5CLENBQVA7QUFDRDs7Ozs7O2tCQXJLa0J0RCxVIiwiZmlsZSI6InRyYW5zbGF0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHRyYW5zbGF0b3IuanNcbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqXG4gKiBUcmFuc2xhdG9yIG1vZHVsZS4gVXNlcyBzdGF0aXN0aWNhbCBtYWNoaW5lIHRyYW5zbGF0aW9uIHRvXG4gKiB0cmFuc2xhdGUgYmV0d2VlbiB0d28gZGlmZmVyZW50IGxhbmd1YWdlcy4gTG9vc2VseSBiYXNlZCBvblxuICogdGhlIElNQiBtb2RlbCAxIGFsZ29yaXRobS5cbiAqL1xuXG5pbXBvcnQgcmVhZGVyIGZyb20gJ3RleHQydG9rZW4nO1xuaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zbGF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZm9yZWlnbldvcmRzICAgPSBbXTtcbiAgICB0aGlzLmZvcmVpZ25MaW5lcyAgID0gW107XG4gICAgdGhpcy5uYXRpdmVXb3JkcyAgICA9IFtdO1xuICAgIHRoaXMubmF0aXZlTGluZXMgICAgPSBbXTtcbiAgICB0aGlzLmRldldvcmRzICAgICAgID0gW107XG4gICAgdGhpcy5zZW50ZW5jZVBhaXJzICA9IFtdO1xuXG4gICAgdGhpcy5wcm9icyAgICAgICAgICA9IHt9O1xuICAgIHRoaXMudHJhbnNtaXNzaW9ucyAgPSB7fTsgLy8gdGhpcyBpcyB0KGVsZilcbiAgICB0aGlzLmNvdW50ZWYgICAgICAgID0ge307XG4gICAgdGhpcy50b3RhbGYgICAgICAgICA9IHt9O1xuICAgIHRoaXMudG90YWxzICAgICAgICAgPSB7fTtcbiAgfVxuXG4gIHRyYWluKG5hdGl2ZVRleHQsIGZvcmVpZ25UZXh0KSB7XG5cbiAgICBpZiAobmF0aXZlVGV4dCA9PT0gdW5kZWZpbmVkIHx8IGZvcmVpZ25UZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmF0aXZlIGFuZCBGb3JlaWduIFRleHRzIGFyZSBib3RoIHJlcXVpcmVkIScpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnZlcnRlZERhdGEgPSByZWFkZXIudGV4dDJ0b2tlbihuYXRpdmVUZXh0KTtcbiAgICB0aGlzLm5hdGl2ZUxpbmVzID0gY29udmVydGVkRGF0YS5saW5lcztcbiAgICB0aGlzLm5hdGl2ZVdvcmRzID0gY29udmVydGVkRGF0YS50b2tlbnM7XG5cbiAgICBjb25zdCBjb252ZXJ0ZWRGb3JlaWduRGF0YSA9IHJlYWRlci50ZXh0MnRva2VuKGZvcmVpZ25UZXh0KTtcbiAgICB0aGlzLmZvcmVpZ25MaW5lcyA9IGNvbnZlcnRlZEZvcmVpZ25EYXRhLmxpbmVzO1xuICAgIHRoaXMuZm9yZWlnbldvcmRzID0gY29udmVydGVkRm9yZWlnbkRhdGEudG9rZW5zO1xuXG4gICAgdGhpcy5zZW50ZW5jZVBhaXJzID0gW107XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5uYXRpdmVMaW5lcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHRoaXMuc2VudGVuY2VQYWlycy5wdXNoKFtcbiAgICAgICAgdGhpcy5uYXRpdmVMaW5lc1tpbmRleF0sXG4gICAgICAgIHRoaXMuZm9yZWlnbkxpbmVzW2luZGV4XVxuICAgICAgXSk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdFRyYW5zbWlzc2lvbnMoKTtcbiAgICB0aGlzLl9pdGVyYXRlRU0oMTApO1xuICB9XG5cbiAgX2luaXRUcmFuc21pc3Npb25zKCkge1xuICAgIGNvbnN0IHByb2JzICAgICAgICAgPSB7fSxcbiAgICAgICAgICB0cmFuc21pc3Npb25zID0ge307XG5cbiAgICBmb3IgKGxldCB3b3JkSW5kZXggPSAwOyB3b3JkSW5kZXggPCB0aGlzLm5hdGl2ZVdvcmRzLmxlbmd0aDsgd29yZEluZGV4KyspIHtcbiAgICAgIGNvbnN0IHdvcmQgPSB0aGlzLm5hdGl2ZVdvcmRzW3dvcmRJbmRleF07XG4gICAgICBjb25zdCB3b3JkX3Bvc3MgPSBbXTtcblxuICAgICAgLy8gaWYgd29yZCBpcyBpbiBzZW50ZW5jZSB0aGVuLi4uXG4gICAgICBmb3IgKGxldCBsaW5lSW5kZXggPSAwOyBsaW5lSW5kZXggPCB0aGlzLm5hdGl2ZUxpbmVzLmxlbmd0aDsgbGluZUluZGV4KyspIHtcbiAgICAgICAgY29uc3Qgc2VudGVuY2UgPSB0aGlzLm5hdGl2ZUxpbmVzW2xpbmVJbmRleF07XG4gICAgICAgIGlmIChzZW50ZW5jZS5pbmRleE9mKHdvcmQpID4gLTEpIHtcbiAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IHRoaXMuZm9yZWlnbkxpbmVzW3RoaXMubmF0aXZlTGluZXMuaW5kZXhPZihzZW50ZW5jZSldO1xuICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBtYXRjaGluZy5zcGxpdCgnICcpO1xuICAgICAgICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB3b3JkX3Bvc3MucHVzaChtYXRjaCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKiBSZW1vdmUgZHVwbGljYXRlcy4gKi9cbiAgICAgIC8qKiBBZGQgcHJvYmFibGUgbWF0Y2hlcy4gKi9cbiAgICAgIHByb2JzW3dvcmRdID0gXy51bmlxdWUod29yZF9wb3NzKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2JzID0gcHJvYnM7XG5cbiAgICBmb3IgKGxldCB3b3JkSW5kZXggPSAwOyB3b3JkSW5kZXggPCB0aGlzLm5hdGl2ZVdvcmRzLmxlbmd0aDsgd29yZEluZGV4KyspIHtcbiAgICAgIGNvbnN0IHdvcmQgPSB0aGlzLm5hdGl2ZVdvcmRzW3dvcmRJbmRleF07XG4gICAgICBjb25zdCB3b3JkX3Byb2JzID0gdGhpcy5wcm9ic1t3b3JkXTtcblxuICAgICAgY29uc3QgdW5pZm9ybV9wcm9iID0gMS4wIC8gd29yZF9wcm9icy5sZW5ndGg7XG5cbiAgICAgIGNvbnN0IHByb2Jfc2V0ID0ge307XG5cbiAgICAgIGZvciAobGV0IHByb2JJbmRleCA9IDA7IHByb2JJbmRleCA8IHdvcmRfcHJvYnMubGVuZ3RoOyBwcm9iSW5kZXgrKykge1xuICAgICAgICBjb25zdCB3ID0gd29yZF9wcm9ic1twcm9iSW5kZXhdO1xuICAgICAgICBwcm9iX3NldFt3XSA9IHVuaWZvcm1fcHJvYjtcbiAgICAgIH1cblxuICAgICAgdHJhbnNtaXNzaW9uc1t3b3JkXSA9IHByb2Jfc2V0O1xuICAgIH1cblxuICAgIHRoaXMudHJhbnNtaXNzaW9ucyA9IHRyYW5zbWlzc2lvbnM7XG4gIH1cblxuICBfaXRlcmF0ZUVNKGNvdW50KSB7XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY291bnQ7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHRvdGFsZiAgPSB7fSxcbiAgICAgICAgICAgIGNvdW50ZWYgPSB7fTtcblxuICAgICAgZm9yIChsZXQgd29yZEluZGV4ID0gMDsgd29yZEluZGV4IDwgdGhpcy5uYXRpdmVXb3Jkcy5sZW5ndGg7IHdvcmRJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IHdvcmQgPSB0aGlzLm5hdGl2ZVdvcmRzW3dvcmRJbmRleF07XG5cbiAgICAgICAgaWYgKCF0aGlzLnByb2JzLndvcmQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBjb25zdCB3b3JkX3Byb2JzID0gdGhpcy5wcm9ic1t3b3JkXTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgY29uc3QgcHJvYl9zZXQgPSB7fTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZm9yIChsZXQgcHJvYkluZGV4ID0gMDsgcHJvYkluZGV4IDwgd29yZF9wcm9icy5sZW5ndGg7IHByb2JJbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgdyA9IHdvcmRfcHJvYnNbcHJvYkluZGV4XTtcbiAgICAgICAgICBwcm9iX3NldFt3XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgY291bnRlZlt3b3JkXSA9IGNvdW50O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0b3RhbGZbd29yZF0gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvdW50ZWYgPSBjb3VudGVmO1xuICAgICAgdGhpcy50b3RhbGYgPSB0b3RhbGY7XG5cbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAvKiogSXRlcmF0ZSBvdmVyIGVhY2ggc2VudGVuY2UgcGFpci4gKi9cbiAgICAgIHRoaXMuc2VudGVuY2VQYWlycy5mb3JFYWNoKHNlbnRlbmNlID0+IHtcblxuICAgICAgICBjb25zdCBuYXRpdmVUb2tlbnMgPSBzZW50ZW5jZVswXS5zcGxpdCgnJyk7XG4gICAgICAgIGNvbnN0IGZvcmVpZ25Ub2tlbnMgPSBzZW50ZW5jZVsxXS5zcGxpdCgnJyk7XG5cbiAgICAgICAgZm9yIChsZXQgZm9yZWlnbiA9IDA7IGZvcmVpZ24gPCBmb3JlaWduVG9rZW5zLmxlbmd0aDsgZm9yZWlnbisrKSB7XG4gICAgICAgICAgdGhpcy50b3RhbHNbZm9yZWlnbl0gPSAwO1xuICAgICAgICAgIGZvciAobGV0IG5hdGl2ZSA9IDA7IG5hdGl2ZSA8IG5hdGl2ZVRva2Vucy5sZW5ndGg7IG5hdGl2ZSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHJhbnNtaXNzaW9ucy5uKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy50cmFuc21pc3Npb25zLm4uZikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICB0aGlzLmNvdW50ZWZbbmF0aXZlXVtmb3JlaWduXSArPVxuICAgICAgICAgICAgICB0aGlzLnRyYW5zbWlzc2lvbnNbbmF0aXZlXVtmb3JlaWduXSAvIHRoaXMudG90YWxzW2ZvcmVpZ25dO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHRoaXMudG90YWxmW25hdGl2ZV0gKz1cbiAgICAgICAgICAgICAgdGhpcy50cmFuc21pc3Npb25zW25hdGl2ZV1bZm9yZWlnbl0gLyB0aGlzLnRvdGFsc1tmb3JlaWduXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBuYXRpdmUgPSAwOyBuYXRpdmUgPCBuYXRpdmVUb2tlbnMubGVuZ3RoOyBuYXRpdmUrKykge1xuICAgICAgICAgIGlmICghdGhpcy5wcm9icy5uKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBjb25zdCBuX3Byb2IgPSBzZWxmLnByb2JzW25hdGl2ZV07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBmb3IgKGxldCBmb3JlaWduID0gMDsgZm9yZWlnbiA8IG5fcHJvYi5sZW5ndGg7IG5hdGl2ZSsrKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbWlzc2lvbnNbbmF0aXZlXVtmb3JlaWduXSA9IHRoaXMuY291bnRlZltuYXRpdmVdW2ZvcmVpZ25dIC8gdGhpcy50b3RhbGZbbmF0aXZlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHRyYW5zbGF0ZShuYXRpdmVXb3JkKSB7XG4gICAgaWYgKCF0aGlzLnRyYW5zbWlzc2lvbnNbbmF0aXZlV29yZF0gfHwgbmF0aXZlV29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1hdGNoIGZvdW5kIScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cmFuc21pc3Npb25zW25hdGl2ZVdvcmRdXG4gIH1cblxufVxuIl19
//# sourceMappingURL=translator.js.map